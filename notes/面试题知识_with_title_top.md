<a name="index">**Index**</a>
<a href="#0">1. 进程有多少种状态？</a>  
<a href="#1">2. 线程之间的通信方式</a>  
<a href="#2">3. 进程通信的方式</a>  
<a href="#3">4. 进程和线程的区别?</a>  
<a href="#4">5. 线程和协成的区别？</a>  
<a href="#5">6. 死锁是怎么产生的？</a>  
<a href="#6">7. 虚拟内存与物理内存</a>  
<a href="#7">8. 条件变量</a>  
<a href="#8">9. TCP与UDP</a>  
<a href="#9">10. OSI七层模型</a>  
<a href="#10">11. TCP如何实现可靠传输</a>  
<a href="#11">12. 滑动窗口</a>  
<a href="#12">13. static关键字的作用</a>  
<a href="#13">14. 野指针怎么产生和避免</a>  
<a href="#14">15. C语言与C++的区别?</a>  
<a href="#15">16. const和define的区别</a>  
<a href="#16">17. extern相关</a>  
<a href="#17">18. const的用法</a>  
<a href="#18"> 19. C 语言里面 volatile可以和 const 同时使用</a>  
<a href="#19">20. 引用的概念</a>  
<a href="#20">21. 指针和引用的区别</a>  
<a href="#21">22. 内联函数和函数的区别，内联函数的作用</a>  
<a href="#22">23. C++的内存管理</a>  
<a href="#23">24. 栈和堆的区别</a>  
<a href="#24">25. 什么是内存泄露，如何检测</a>  
<a href="#25">26. 内存对齐  </a>  
<a href="#26">27.浅拷贝与深拷贝</a>  
<a href="#27">28. C++中的多态</a>  
<a href="#28">29. 协变与逆变</a>  
<a href="#29">30. 重载, 重写 与重定义</a>  
# <a name="0">1. 进程有多少种状态？</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

创建,就绪,执行,阻塞,终止
 *  创建: 一个进程启动就进入创建状态,需要获取系统资源创建进程管理块(PCB)完成资源创建
 *  就绪: 在创建状态完成之后, 进程已经准备好,处于就绪状态,但是未获得处理器资源,无法运行
 *  运行: 获取处理器资源,被系统调度,当具有时间片开始进入运行状态.如果进程的时间片用完了就进入就绪状态
 *  阻塞: 在运行状态期间,如果进行阻塞操作,此时进程暂时无法操作进入阻塞态,完成后进入就绪状态,等待再次获取处理器资源终
 *  终止状态: 进程结束或是被操作系统终止.

# <a name="1">2. 线程之间的通信方式</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

信号, 互斥锁, 读写锁, 自旋锁, 条件变量, 信号量 (六种)

1. 信号: Linux中使用pthread_kill()函数对线程发信号

    1. 互斥锁,读写锁,自旋锁.    
        	* 互斥锁确保同一时间只有一个线程访问共享资源,当锁被占用时试图对其加锁的线程都会进入阻塞状态
         * 读写锁确保同一时间可以有多个线程读取,但是同一时间只能有一个线程写入.
             		自旋锁上锁受阻时线程不阻塞而是在循环中轮询查看能否获得该锁，没有线程的切换因而没有切换开销，不过对 CPU 的霸占会导致 CPU 资源的浪费。
             			 所以自旋锁适用于并行结构（多个处理器）或者适用于锁被持有时间短而不希望在线程切换产生开销的情况。 

        * 互斥锁：共享资源只允许一个进程进行访问，进程没有请求到锁后，会继续进行其它事，当锁被释放后，再来申请;
        * 自旋锁：进程没有请求到锁后，会原地等待，直到锁被释放

2. 条件变量: 条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的，条件变量始终与互斥锁一起使用。

3. 信号量: 信号量实际上是一个非负的整数计数器，用来实现对公共资源的控制。在公共资源增加的时候，信号量就增加；公共资源减少的时候，信号量就减少；只有当信号量的值大于0的时候，才能访问信号量所代表的公共资源。

    

**共享内存 (Shared Memory) 配合同步机制 (Mutex/Semaphore/Condition Variable)**：

- **原因**：这是最基础且高效的通信方式，但也是并发编程中需要重点掌握的同步原语。面试官通常会考察你对竞态条件、死锁等并发问题的理解，以及如何使用锁和信号量来解决这些问题。
- 回答要点：
  - 解释共享内存允许多个线程直接访问同一块内存区域。
  - 强调由于多个线程同时读写共享数据可能导致数据不一致，因此需要同步机制。
  - 简述互斥锁（保护临界区）、信号量（控制资源访问数量）、条件变量（线程间的等待和通知）的作用。
  - 提及这种方式的优点是高效，缺点是需要开发者显式地管理同步，容易出错。

**消息传递 (Message Passing) - 以消息队列为例**：

- **原因**：消息传递是一种更高级别的通信方式，能够降低线程间的耦合度，并且在某些并发模型（如 Actor 模型）中广泛应用。消息队列是消息传递的典型实现。
- 回答要点：
  - 解释线程通过发送消息到队列，而其他线程从队列接收消息进行通信。
  - 说明消息队列可以是同步的（发送方阻塞直到消息被接收）或异步的（发送方发送后继续执行）。
  - 强调消息传递的优点是避免了直接共享内存带来的复杂同步问题，缺点是可能存在一定的性能开销（数据复制）。

**互斥锁和条件变量 (Mutex & Condition Variable) 结合使用**：

- **原因**：这两种机制经常一起使用，用于实现更复杂的线程同步和通信逻辑，例如生产者-消费者模型。
- 回答要点：
  - 解释互斥锁用于保护共享状态的访问。
  - 解释条件变量允许线程在特定条件不满足时等待，并在条件满足时被唤醒。
  - 通过一个简单的例子（如生产者-消费者）说明它们如何协同工作来实现线程间的协作。

**原子操作 (Atomic Operations)**：

- **原因**：虽然原子操作通常用于对单个变量进行无锁的线程安全更新，但它们也可以作为轻量级的线程间通信和同步机制。
- 回答要点：
  - 解释原子操作是不可分割的操作，可以保证在多线程环境下执行的完整性，不会被其他线程中断。
  - 举例说明常见的原子操作（如原子计数器、原子布尔标志）。
  - 说明其优点是避免了锁的开销，但通常只适用于简单的同步场景。

# <a name="2">3. 进程通信的方式</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

管道,命名管道,信号,消息队列,共享内存,内存映射,信号量,Socket

1. 管道（匿名管道）：本质上是内核中维护的一块内存缓冲区，Linux系统中由pipe()函数创建，只能用于具有亲缘关系的进程间通信。
2. 命名管道：不同于匿名管道之处在于它提供了一个路径名与之关联，进程通过访问该路径就能相互通信，适用于没有亲缘关系的进程间通信。
3. 信号：一种异步通信方式，信号可以让一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。
4. 消息队列：是一个消息链表且随内核持续，具有特定的格式和特定的优先级，由具有写权限的进程添加消息，由具有读权限的进程读走消息。
5. 共享内存：允许两个或者多个进程共享物理内存的同一块区域（通常被称为段），无需内核介入，速度比管道快。
6. 内存映射 ：将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件。
7. 信号量：主要用来解决进程和线程间并发执行时的同步问题，信号量操作分为P操作和V操作，P将信号量值-1，V将信号量值+1。当信号量值<=0时，进行P操作进线程会被阻塞，		直到另一个进程或线程执行了V操作将信号量的值大于0时。
8. Socket 套接字：一般用于网络中不同主机上的进程之间的通信，且提供了应用层进程利用网络协议交换数据的机制。

1. **管道 (Pipes)**：
   - **原理**：管道是在两个相关进程之间创建一个单向或双向的数据通道。数据以字节流的形式在管道中传输。
   - 类型：
     - **匿名管道 (Anonymous Pipes)**：通常用于父子进程或具有亲缘关系的进程之间的通信。它们是临时的，只在进程存在期间有效。`int pipe(int pipefd[2]);`使用read和write进行管道读写，使用close关闭管道
     - **命名管道 (Named Pipes / FIFOs)**：允许不相关的进程之间进行通信。它们在文件系统中有一个固定的名称，可以被多个进程打开进行读写。`int mkfifo(const char *pathname, mode_t mode);`
   - **优点**：简单易用，对于父子进程间的简单数据传输很方便。
   - 缺点：
     - 匿名管道只能用于相关进程。
     - 管道中的数据是无格式的字节流，需要进程自己约定数据的格式。
     - 进程必须有一个先读或先写的过程，否则可能会阻塞。
2. **消息队列 (Message Queues)** `int msgget(key_t key, int msgflg)`：
   - **原理**：消息队列是一个存在于内核中的消息链表。一个进程可以将消息放入队列，而另一个或多个进程可以从队列中取出消息。消息通常包含类型信息，接收进程可以选择性地接收特定类型的消息。
   - 优点：
     - 允许不相关的进程进行通信。
     - 提供了异步通信的能力。
     - 可以根据消息类型进行选择性接收。
   - 缺点：
     - 需要进行数据的拷贝，有一定的开销。
     - 队列的容量可能有限制。
     - 通信的实时性可能不如共享内存。
3. **共享内存 (Shared Memory)** `int shmget(key_t key, size_t size, int shmflg);`：
   - **原理**：共享内存允许多个进程访问同一块物理内存区域。这是最快速的IPC方式，因为进程直接读写内存，不需要内核进行数据拷贝。
   - **优点**：速度快，适用于大量数据的传输。
   - **缺点**：需要进程自己进行同步控制（例如，使用信号量、互斥锁等）来避免并发访问导致的数据不一致性。同步机制的实现和管理比较复杂，容易出错。
4. **信号量 (Semaphores)**```int semget(key_t key, int nsems, int semflg);```：
   - **原理**：信号量是一种计数器，用于控制多个进程对共享资源的访问。进程可以对信号量进行P操作（等待）和V操作（释放）。
   - **用途**：主要用于进程间的同步和互斥，常与共享内存等IPC机制结合使用，以保证数据的一致性。
5. **信号 (Signals)** ```kill```：
   - **原理**：信号是一种异步事件通知机制，一个进程可以发送信号给另一个进程，接收进程可以预先定义信号处理函数来响应不同的信号。
   - **优点**：简单，开销小。
   - **缺点**：能够传递的信息有限，主要用于通知事件的发生，而不是大量数据的传输。
6. **套接字 (Sockets)**：
   - **原理**：套接字最初是为网络通信设计的，但也可以用于同一主机上不同进程之间的通信（Unix Domain Sockets）。它提供了一个通用的接口，可以进行双向的数据传输。
   - **优点**：通用性强，既可以用于本地进程通信，也可以用于网络通信。提供了可靠的数据传输机制。
   - **缺点**：相对于其他IPC方式，开销可能稍大一些。

**面试回答建议：**

- **重点介绍核心机制**：选择管道、消息队列、共享内存这三种最常见且重要的IPC方式进行详细解释。
- **说明原理和特点**：清晰地描述每种机制的工作原理和主要特点。
- **对比优缺点**：能够分析每种IPC方式的优点和缺点，例如性能、易用性、适用场景等。
- **提及同步问题**：对于共享内存，务必强调同步的重要性，并提及常用的同步机制（信号量、互斥锁）。
- **结合应用场景**：如果可以，举例说明在什么类型的问题或系统中会使用哪种IPC方式。例如，管道常用于简单父子进程间的通信，消息队列适用于需要异步处理的任务，共享内存适用于需要高速数据交换的场景。
- **简洁明了**：用清晰、简洁的语言进行解释，避免过于深入的细节，除非面试官有进一步的追问。

# <a name="3">4. 进程和线程的区别?</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

地址空间,开销,并发性,内存

1. 地址空间:进程有独立的地址空间, 线程有自己的堆栈和局部变量,但线程之间没有单独的地址空间

2. 开销: 进程的上下文切换时间开销远大于线程的上下切换时间
3. 进程的并发性较低,线程的并发性高
4. 每个独立的进程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，依赖应用程序。
5. 进程有独立的内存空间，除CPU外，系统不会为线程分配内存
6. 一个进程崩溃后， 在保护模式下不会对其他进程产生影响，但是一个线程崩溃了，整个进程都死掉。
7. 

| 通信方式     | 是否共享内存 | 是否支持无亲缘进程 | 数据传输速度 | 适用场景             |
| ------------ | ------------ | ------------------ | ------------ | -------------------- |
| 匿名管道     | 否           | 否                 | 中           | 父子进程简单数据交换 |
| 命名管道     | 否           | 是                 | 中           | 本地无关进程通信     |
| 消息队列     | 否           | 是                 | 中           | 异步消息传递         |
| 信号         | 否           | 是                 | 慢           | 异步事件通知         |
| 共享内存     | 是           | 是                 | 快           | 大量数据交换         |
| 信号量       | 否           | 是                 | -            | 协同资源访问         |
| 套接字       | 否           | 是（支持远程）     | 中           | 跨网络或复杂结构通信 |
| 内存映射文件 | 是           | 是                 | 快           | 持久化大数据共享     |

# <a name="4">5. 线程和协成的区别？</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

1. 线程是操作系统的资源，线程的创建、切换、终止都会造成资源的浪费，而协程是靠编译语言来实现的，所以协程也被称作用户态线程
2. 线程是并行的，协程是并发的。
3. 线程同步，协程异步
4. 线程抢占式，协程非抢占式，需要手动切换 

# <a name="5">6. 死锁是怎么产生的？</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

1. 死锁：两个或两个以上得进程在争夺共享资源时产生的一种互相等待的现象。

2. 死锁的条件：

   1. 互斥条件，进程对资源的使用是独占形式了，同一时间只有一个进程能够使用该资源，其他进程的请求会等待。

   2. 请求和保护条件，当一个进程未使用完一个资源，又请求另一个资源，而那个资源正在被另一个进程使用，该请求进程阻塞，在这期间，请求进程不会释放已有资源。
   3. 不剥夺条件，一个进程未使用完的资源，无法被剥夺，只有等进程完成后自己释放该资源。
   4.  环路条件，多个进程互相等待，形成一个环路。死锁的原因：资源竞争。

3. 死锁的解决方法：有序资源分配法，银行家算法 

# <a name="6">7. 虚拟内存与物理内存</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

1. 直接使用物理内存的缺陷：隔离性差，物理内存不够用； 

2. 虚拟内存；每个进程都可以自己搞一份，在需要的时候映射到物理内存，变相扩大了物理内存；同时隔离性也比较好；

# <a name="7">8. 条件变量</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：

* 个线程等待"条件变量的条件成立"而挂起；
* 另一个线程使"条件成立"（给出条件成立信号）。

# <a name="8">9. TCP与UDP</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

1. TCP是面向对象连接；而UDP是无面向对象连接 

2. TCP确保所传输的数据一定会到达目的地，但时间却不能保证；而UDP不确保数据会按原来顺序到达，但具有实时性 

3. TCP的使用场景是不在意传输数据速度，但在意传输数据准确；而UDP的使用场景则是对实时性要求较高 

4. TCP的首部开销大，占用20字节；而UDP的首部开销小，只占用8个字节
5. TCP只支持点对点的数据传输；而UDP支持一对一、一对多、多对多等各种场景
6. TCP有拥塞控制和流量控制来确保数据的安全性，但如果网络拥塞的话，速度会比较慢；UDP即使在网络拥塞的时候，传输速度也不会慢

# <a name="9">10. OSI七层模型</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

应用层、表示层、会话层、传输层、网络层、数据链路层、物理层

* 应用层，管理应用进程间的通信规则。

* 表示层，对数据进行处理。

* 会话层，用来管理进程。

* 传输层，提供数据的传输服务。

* 网络层，进行逻辑地址的查询。

* 数据链路层，建立节点的连接和信息校验。

* 物理层，负责最底层的数据传输。  

# <a name="10">11. TCP如何实现可靠传输</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

1. 首先可靠传输是指没差错、不丢失、不重复、按序到达。

2. 相应的TCP头部有检验和来保证不出差错，然后会采用重传和确认机制来保障不重复，不丢失，按序，还会有流量控制和拥塞控制来减少丢包率。

# <a name="11">12. 滑动窗口</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

滑动窗口机制主要是通过窗口大小实现流量控制，进而解决发送方发送数据过快、过多导致的接收端缓存区数据溢出导致的丢包现象；回退n步协议、停等式协议、选择重传协议





# <a name="12">13. static关键字的作用</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

关键字、作用域、生命周期、共享数据 

1. 限制数据的作用域（隐藏） 所有没有加 static 的全局变量和函数都具有全局可见性，其它源文件中也可以访问。被 static 修饰的全局变量和函数只能在**当前源文件中访问**，其它源文件访问不了，利用这个特性可以在不同的文件中定义同名变量和同名函数，而不必担心命名冲突。
2. 延长数据的生命周期 ,加`static`的局部变量 的 静态变量存储在**静态区**，直到程序运行结束才会释放。
3. 静态成员被该类所有对象共享,不管创建多少个该类的对象，所有对象都**共享这一块内存**。静态成员**本质上属于类**，可以**通过类名直接访问**。
4. 静态成员函数中不能访问普通的成员变量，**只能访问静态成员变量**，并且在静态成员函数中**没有 this 指针**。



# <a name="13">14. 野指针怎么产生和避免</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

概念: 野指针是指指向的位置是随机的、不可知的、不正确的。(一般是没有初始化)

产生原因:

	1. 指针变量未初始化或随便赋值: 指针变量没有初始化, 其值随机, 如果对其解引用, 结果未知
	1. 指针释放后未置空: 有时候指针在释放后没有赋值为`nullptr`, 虽然指针变量指向的内存被释放到了,但是指针变量中的值还在, 这时指针变量就是指向一个未知的内存, 如果解引用, 结果未知
	1. 指针操作超出了变量的作用域: 函数中变量了局部变量的地址或者引用, 因为局部变量除了作用域就被释放了,这时候返回的地址指向的内存也是未知的.

避免:

	1. 指针变量一定要初始化, 可以初始化为`nullptr`, 对`nullptr`操作不会有问题
	1. 释放后置为`nullptr`



# <a name="14">15. C语言与C++的区别?</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

面向对象,面向过程, 重载, void, struct, 函数参数默认值, 内联函数, 引用, 动态内存分配, 作用域

1. C语言面向过程, C++支持面向对象, 所有C语言没有面向对象的封装, 继承, 多态等特性
2. C++支持函数重载, C语言不支持;
3. C语言`struct`中不能有函数, 而C++语言`struct`中可以有函数;
4. C语言函数参数不支持默认值, 而C++语言支持参数默认值;
5. C++语言迟滞内联函数, 而C语言不支持;
6. C++支持引用, C语言不支持
7. C语言采用`malloc`和`free`函数动态申请和释放内存, 而C++使用`new`和`delete`运算符
8. C语言只有局部和全局两个作用域, 而C++中有局部, 全局, 类, 名称空间作用域



# <a name="15">16. const和define的区别</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

作用、编译阶段、预处理阶段、简单替换、类型检查、内存,

const 在 C 语言中表示只读，编译器禁止对它修饰的变量进行修改，在 C++ 中增加了常量的语义。而 define 用于定义宏，而宏也可以用于定义常量。

1. const 生效于编译阶段，而 define 生效于预处理阶段； 

2. define只是简单的字符串替换，没有类型检查，而 const 有对应的数据类型，编译器要进行判断的，可以避免一些低级的错误； 
3. 用 define 定义的常量是不可以用指针变量去指向的，用 const 定义的常量是可以用指针去指向该常量的地址的；
4. define 不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大，const  在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝； 
5. 可以对 const 常量进行调试，但是不能对宏常量进行调试。 



# <a name="16">17. extern相关</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

extern的作用: 声明外部变量和函数、静态存储区（全局区）

1. `extern` 可以置于变量声明或者函数声明前，以表示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其它文件中寻找其定义。
2. extern 变量表示声明一个变量，表示该变量是一个外部变量，也就是全局变量，所以 extern 修饰的变量保存在静态存储区（全局区），全局变量如果没有显示初始化，会默认初始化为 0
3. . extern "C" 的作用是为了能够正确的实现 C++ 代码调用 C 语言代码。加上 extern "C" 后，会指示编译器这部分代码按照 C 语言（而不是 C++）的方式进行编译。

# <a name="17">18. const的用法</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

 变量、指针、函数参数、成员、成员方法

1. 用在变量身上，表示该变量只读，不能对它的值进行修改 

2. 结合指针一起使用 

   * const int * p; 

   * 常量指针 int * const p; 

   * 指针常量 const int * const p; 

   * const int * p 是常量指针，表示指针变量 p 所指向的内容不能修改，指针变量 p 的内容可以修改； 

   * int * const p 是指针常量，表示指针变量 p 的内容不能修改，指针变量 p 所指向的内容可以修改； 

   * const int * const p 表示指针变量 p 的内容和所指向的内容都不可以修改。  

     

3. const 用于函数参数 void foo(const int * p); void foo(const int & p);    const 用于形参时说明形参在函数内部不能被改变，这是非常有用的，有时候函数参数传递指针或者引用，在函数内部不希望对指针和引用指向的数据进行修改，可以加上 const。

4. 在类中修饰成员方法，防止在方法中修改非 static 成员

5. const修饰的全局变量会变为仅仅该文件可见。如果想在其他文件直接使用需要在其他文件进行extern声明一下。

6. const 修饰类的成员变量，如果 const 修饰的是非静态的成员变量，可以在构造函数中对该变量进行初始化；如果 const 修饰的是静态的成员变量，则需要在类外对该变量进行初始化。   



# <a name="18"> 19. C 语言里面 volatile可以和 const 同时使用</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

volatile 的含义是防止编译器对该代码进行优化，这个值可能变掉的。

而 const 的含义是在代码中不能对该变量进行修改。



# <a name="19">20. 引用的概念</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

概念: 引用可以看做是数据的一个别名

注意: 

* 引用必须引用合法的内存空间 

- 引用在定义时必须初始化 
- 引用一旦初始化后，就不能再引用其它数据 
- 引用在定义时需要加上 &，在使用时不能加 &，使用时加 & 表示取地址 
- 函数中不要返回局部变量的引用 
- 引用的本质是指针，低层的实现还是指针。



# <a name="20">21. 指针和引用的区别</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>



区别:	

1. 指针是一种数据类型，用于保存地址类型的数据，而引用可以看成是变量的别名。
2. 引用不可以为空, 当被创建时必须初始化, 而指针变量可以是空值, 在任何时候都可以初始化
3. 指针有多级, 引用只能有一级
4. 引用使用时无需解引用, 而指针需要解引用
5. 指针变量的值可以是NULL, 但是引用的值不可以为NULL
6. 指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了
7. `sizeof `引用得到的是所指向的变量（对象）的大小，而 `sizeof `指针得到的是指针变量本身的大小
8. 指针作为函数参数传递时传递的是指针变量的值，而引用作为函数参数传递时传递的是实参本身，而不是拷贝副本
9. 指针和引用进行++运算意义不一样。



# <a name="21">22. 内联函数和函数的区别，内联函数的作用</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

函数调用开销、寻址、展开代码、提高效率、宏定义 , inline

区别:

1. 内联函数与普通函数的区别:
   1. 内联函数函数避免了函数调用的开销; 普通函数有调用的开销;
   2. 普通函数调用时需要寻址, 内联函数不需要寻址
   3. 内联函数体要求代码简单,不能复杂, 不然会被编译器优化成普通函数执行
2. 内联函数的作用:
   1. 编译器预处理,在调用内联函数的地方将内联函数的语句复制到调用函数的地方,直接展开代码执行,提高效率.,
   2. 同时解决宏定义的问题.

# <a name="22">23. C++的内存管理</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

C++ 的内存分区主要有：

* 代码区

* 未初始化数据区（BSS）

* 已初始化数据区（DATA）

* 栈区（Stack）

* 堆区（Heap）

实际中;

​	栈区

​	空闲区域

​	堆区

​	数据区(已初始化	未初始化)

​	代码区

# <a name="23">24. 栈和堆的区别</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

管理方式、空间大小、是否产生内存碎片、生长方向、分配方式、分配效率 

1. 管理方式 对于栈来讲，是由编译器自动管理，无需手动控制；对于堆来说，分配和释放都是由程序员控制的

2. 空间大小 总体来说，栈的空间是要小于堆的。堆内存几乎是没有什么限制的；但是对于栈来讲，一般是有一定的空间大小的。

3. 碎片问题 对于堆来讲，由于分配和释放是由程序员控制的（利用new/delete 或 malloc/free），频繁的操作势必会造成内存空间的不连续，从而造成大量的内存碎片，使程序效率降低。

4. 对于栈来讲，则不会存在这个问题，因为栈是先进后出的数据结构，在某一数据弹出之前，它之前的所有数据都已经弹出。
5. 生长方向 对于堆来讲，生长方向是向上的，也就是沿着内存地址增加的方向，对于栈来讲，它的生长方式是向下的，也就是沿着内存地址减小的方向增长。
6. 分配方式 堆都是动态分配的，没有静态分配的堆。栈有两种分配方式：静态分配和动态分配，静态分配是编译器完成的，比如局部变量的分配；动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器实现的，无需我们手工实现。
7. 分配效率 栈是机器系统提供的数据结构，计算机会在底层对栈提供支持，分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率很高。
8. 堆的效率要比栈底的多。

# <a name="24">25. 什么是内存泄露，如何检测</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

概念、避免内存泄露、检测

1. 内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

2. 避免内存泄露的方法主要就是要有良好的编码习惯，动态开辟内存空间，及时释放内存。也可以采用智能指针来避免内存泄露。
3. 可以采用静态分析技术、源代码插装技术等进行检测。

# <a name="25">26. 内存对齐  </a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

什么是内存对齐、内存对齐的原因、内存对齐的规则  

1. 什么是内存对齐 现代计算机中内存空间都是按照 字节（byte）划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数 k（通常它为4或8）的倍数，这就是所谓的内存对齐。
2. 内存对齐的原因 - 平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的。某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
3. 内存对齐的规则 - 每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。可以通过预编译命令 #pragma pack(n)，n = 1,2,4,8,16 来改变这一系数



# <a name="26">27.浅拷贝与深拷贝</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

1.  浅拷贝 又称值拷贝, 将源对象的值拷贝到目标对象中, 如果对象中有某个成员是指针类型数据, 并且是在堆中创建, 则使用浅拷贝仅仅拷贝的是这个指针变量的值, 也就是在目标对象中该指针类型数据和源对象中的该成员指向的是同一块堆空间. 这样会带来一个问题，就是在析构函数中释放该堆区数据，会被释放多次。默认的拷贝构造函数和默认的赋值运算符重载函数都是浅拷贝。 
2. 深拷贝 深拷贝在拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样指针成员就指向了不同的内存位置。并且里面的内容是一样的，这样不但达到了拷贝的目的，还不会出现问题，两个对象先后去调用析构函数，分别释放自己指针成员所指向的内存。即为每次增加一个指针，便申请一块新的内存，并让这个指针指向新的内存，深拷贝情况下，不会出现重复释放同一块内存的错误。 



# <a name="27">28. C++中的多态</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

1. 静态多态(编译时多态), 编译期间完成, 编译器会根据实参类型来选择调用合适的函数,如果有合适的函数就调用, 没有就发出警告. 静态多态有函数重载, 运算符重载, 泛型编程等.
2. 动态多态(运行时多态) , 动态多态是在程序运行时根据基类的引用（指针）指向的对象来确定自己具体该调用哪一个类的虚函数。当父类指针（引用）指向 父类对象时，就调用父类中定义的虚函数；即当父类指针（引用）指向 子类对象时，就调用子类中定义的虚函数。

# <a name="28">29. 协变与逆变</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

如果类型 **Car** 是类型 **Vehicle** 的子类型（subtype，**Car** ≤ **Vehicle**，可以在任何出现 **Vehicle** 的地方用 **Car** 代替），那么关于 **Car** 和 **Vehicle** 的复杂类型（如 **std::vector<Car>** 和 **std::vector<Vehicle>**）之间的关系如下：

- **std::vector<Car>** 是 **std::vector<Vehicle>** 的子类型，所有出现 **std::vector<Vehicle>** 的地方都可以用 **std::vector<Car>** 代替，即代替方向一致，则称之为协变（covariance）。
- **std::vector<Vehicle>** 是 **std::vector<Car>** 的子类型，所有出现 **std::vector<Car>** 的地方都可以用 **std::vector<Vehicle>** 代替，即代替方向相反，则称之为逆变（cotravariance）。
- **std::vector<Vehicle>** 和 **std::vector<Car>** 之间没有关系，则称之为不变（invariance）。



# <a name="29">30. 重载, 重写 与重定义</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

* 重载（overload）: 是指在同一个作用域内，定义多个函数名相同但参数列表不同的函数。[重载函数](https://so.csdn.net/so/search?q=重载函数&spm=1001.2101.3001.7020)可以根据传入的参数类型和数量的不同，自动匹配调用相应的函数。重载函数的返回值类型可以相同也可以不同。

```c++
#include <iostream>
using namespace std;

// 重载示例
int add(int a, int b)
{
	return a + b;
}

double add(double a, double b)
{
	return a + b;
}

int main()
{
	cout << add(1, 2) << endl;	   // 输出 3
	cout << add(1.0, 2.1) << endl; // 输出 3.1
	return 0;
}

```

* 重写（override）: 重写是指在[派生类](https://so.csdn.net/so/search?q=派生类&spm=1001.2101.3001.7020)中重新定义基类中已有的虚函数，使得派生类对象调用该虚函数时，会执行派生类中的定义而不是基类中的定义。重写需要满足函数名、参数列表和返回值类型完全一致的要求，同时基类中该函数必须是虚函数。

```c++
#include <iostream>
using namespace std;

// 重写示例
class Base
{
public:
	virtual void func()
	{
		cout << "Base::func()" << endl;
	}
};

class Derived : public Base
{
public:
	virtual void func()
	{
		cout << "Derived::func()" << endl;
	}
};

int main()
{

	// 方法1：new，父类指针指向子类对象
	Base *p = new Derived();
	p->func(); // 输出 Derived::func()
	delete p;

	cout << "----" << endl;
	// 或者
	
	// 方法2：不new，父类指针指向子类对象
	Derived dd;
	Base *pp = &dd;
	pp->func(); // 输出 Derived::func()

	cout << "----" << endl;
	// 或者

	// 方法3：不new，父类引用引用子类对象
	Derived ddd;
	Base &ppp = ddd;
	ppp.func(); // 输出 Derived::func()
	return 0;
}
```



* 重定义: 子类重新定义父类中有相同名称的非虚函数 ( 参数列表可以不同 ) 。

```c++
 
class AA
{
public:
    void print()
    {
        cout << "父类" << endl;
    }
};
class BB : public AA
{
public:
    void print(int x)//这叫重定义，此时A类中的print()被隐藏
    {
        cout << "子类:" << x  << endl;
    }
};
 
void main()
{
    int x = 1;
    BB b; //子类
    AA a; //父类
    a.print();//访问父类的print()
    b.print(x);//访问子类的print()
    b.AA::print();//访问父类的print()
    //b.print();error:函数参数太少
}
```

