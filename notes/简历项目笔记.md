<a name="index">**Index**</a>
<a href="#0">1. 项目</a>  
&emsp;<a href="#1">1.1 项目简介</a>  
&emsp;<a href="#2">1.2 关键技术分析</a>  
&emsp;<a href="#3">1.3 遇到了哪些问题</a>  
&emsp;<a href="#4">1.4 代码详解</a>  
&emsp;&emsp;<a href="#5">1.4.1 同步队列</a>  
&emsp;&emsp;&emsp;<a href="#6">1.4.1.1 Take函数</a>  
&emsp;&emsp;&emsp;<a href="#7">1.4.1.2 Add函数</a>  
&emsp;&emsp;&emsp;<a href="#8">1.4.1.3 Stop函数</a>  
&emsp;&emsp;<a href="#9">1.4.2 线程池本身</a>  
&emsp;<a href="#10">1.5性能优化</a>  
<a href="#11">2. 语法基础相关</a>  
&emsp;<a href="#12">2.1 智能指针</a>  
&emsp;<a href="#13">2.2 C++中的内存分配情况</a>  
&emsp;<a href="#14">2.3 C++中的指针参数传递和引用参数传递</a>  
&emsp;<a href="#15">2.4 C++中的const和static关键字</a>  
&emsp;<a href="#16">2.5 C和C++的区别</a>  
&emsp;<a href="#17">2.6 C++与Java的区别</a>  
&emsp;<a href="#18">2.7 C++里是怎么定义常量的? 常量放在内存的哪个位置?</a>  
&emsp;<a href="#19">2.7 C++中重载和重写, 重定义的区别</a>  
&emsp;<a href="#20">2.9 介绍C++所有的构造函数</a>  
&emsp;<a href="#21">2.10 C++的四种强制类型转换</a>  
&emsp;<a href="#22">2.11 指针与引用的区别</a>  
&emsp;<a href="#23"> 2.12 野指针(wild)与悬空(dangling)指针有什么区别? 如何避免?</a>  
&emsp;<a href="#24">2.13 函数指针和指针函数</a>  
&emsp;<a href="#25">2.14 堆与栈的区别</a>  
&emsp;<a href="#26">2.15  new/delete malloc/free的区别</a>  
&emsp;<a href="#27">2.16 volatile和extern关键字</a>  
&emsp;<a href="#28">2.17 define和const的区别(编译阶段,安全性,内存占用等)</a>  
&emsp;<a href="#29">2.18 面向对象的三大特征</a>  
&emsp;<a href="#30">2.19 多态的实现</a>  
&emsp;<a href="#31">2.20 析构函数一般写成虚函数的原因</a>  
&emsp;<a href="#32">2.21 构造函数的执行顺序? 析构函数的执行顺序?</a>  
# <a name="0">1. 项目</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

## <a name="1">1.1 项目简介</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

在处理大量并发任务的时候, 如果按照传统方式, 一个请求一个线程来处理请求任务, 大量的线程创建和销毁将消耗过多的资源. 为了解决这些问题,线程池通过在系统中预先创建一定数量的线程, 当任务请求来到时从线程池中分配一个预先创建的线程去处理任务, 线程在处理完任务后还可以重用, 不会销毁, 而是等待下次任务的到来 , 这样通过线程池能避免大量的线程创建好销毁动作, 从而节省系统资源.

## <a name="2">1.2 关键技术分析</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

1. 线程池分为半同步半异步线程池和领导者追随者线程池, 本项目为半同步半异步线程池. 

2. 主要由三层组成: 同步服务层, 排队层和异步服务层, 其中排队层居于核心地位, 因为上层会将任务加到排队层中, 异步服务层同时也会取出任务.

3. 线程池主要有两个活动过程: 

   1. 外面不断的往线程池添加任务 
   2. 线程池内部不断的取任务执行 

   4. 活动过程: 
      * 一开始线程池会启动一定数量的线程, 这些线程属于异步层, 主要用来处理排队层中的任务
      * 如果排队层中的任务数为空, 则这些线程等待任务的到来
      * 如果发现排队层中有任务了, 线程池则会从等待的这些线程中唤醒一个来处理新任务
      * 同步服务层则会不断的将新的任务添加到同步排队层中

## <a name="3">1.3 遇到了哪些问题</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

1. 出现过内存暴涨的问题, 后来排查发现是异步层中的线程处理不过来, 而同步层的任务不断增加, 导致排队层的任务过多.

   怎样解决的:  给排队层加上限的控制, 当排队层的任务数达到上限时, 就不让上层的任务添加进来, 起到限制和保护.

2. 在测试的时候发现线程池中的线程不能挂死, 不然会耗尽线程池中的线程, 造成假死现象; (程序员想办法去避免)

3. 也要避免长时间去执行一个任务, 不然会导致后面的任务大量堆积而得不到及时处理, 对于耗时较长的任务可以用单独的线程去处理.(程序员想办法去避免), (或者加个定时器, 超时了就把线程挂掉)(当然我提供了Stop函数能让用户去终止任务)

## <a name="4">1.4 代码详解</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

分同步队列,线程池的实现, 测试代码

### <a name="5">1.4.1 同步队列</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

* 同步队列主要是保护队列中共享数据线程安全,还为上一层服务层提供添加新任务的接口, 以及为下一层异步服务层提供取任务的接口. 同时, 还要限制任务数的上限, 避免任务过多导致内存暴涨的问题.
* 用到的知识点:  C++11的锁, 条件变量, 右值引用, `std::move`以及`std::forward`

#### <a name="6">1.4.1.1 Take函数</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

1. 先创建一个`unique_lock`获取`mutex`, 然后再通过条件变量`m_notEmpty`来等待判断式, 判断式由两个条件组成, 一个是停止的标志, 另一个是不为空的条件
2. 当不满足任何一个条件时, 条件变量会释放`mutex`并将线程置于`waiting`状态, 等待其他线程调用`notify_one`/`notify_all`将其唤醒;
3. 当满足任何一个条件时, 则继续往下执行后面的逻辑, 即将队列中的任务取出, 并唤醒一个正处于等待状态的添加任务的线程去添加任务.
4. 当出去`waiting`状态的线程被`notify_one`或`notify_all`唤醒时, 条件变量会先重新获取`mutex`, 然后再检查条件是否满足,如果满足,则往下执行, 如果不满足, 则释放`mutex`继续等待.

#### <a name="7">1.4.1.2 Add函数</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

 Add的过程和Take的过程是类似的, 也是先获取`mutex`,然后检查条件是否满足

1. 不满足条件时, 释放`mutex`继续等待
2. 如果满足条件,则将新的任务插入到队列中, 并唤醒任务的线程去取数据

#### <a name="8">1.4.1.3 Stop函数</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

Stop接口能让Stop函数为了保证线程安全, 先获取`mutex`, 再将其标志置为`true`之后, 再唤醒所有的等待的线程, 等待的条件是`m_needStop`,满足条件后, 所有线程会继续往下执行, 当线程在`m_needStop`为`true`时会退出, 所有的等待线程会相继退出.



### <a name="9">1.4.2 线程池本身</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

完整的线程池包括三层: 同步服务层, 排队层 和异步服务层

采用了生产者-消费者模式, 同步层是生产者, 不断将新任务丢到排队层中, 异步层是消费者,是由线程池中预先创建的线程去处理排队层中的任务. 排队层是一个同步队列, 内部保证了上下两层对共享数据的安全访问, 同时还要保证队列不会被无限制地添加任务导致内存暴涨. 最后, 线程池还提供了一个停止的接口, 能让用户在需要的时候停止线程池的运行. 



## <a name="10">1.5性能优化</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

1. 提供了Stop接口, 以便让用户能终止任务, 以提高性能
2. 没有改进前, 每次获取到互斥锁之后, 只能获取一个数据, 这是队列中可能有多条数据, 如果每个数据都加锁获取, 效率是很低的, 后来改进之后, 做到一次加锁就能将队列中所有数据都取出来, 大大减少了加锁的次数. 在获取互斥锁之后, 我们不再只获取一条数据, 而是通过`std::move`来将队列中的所有数据`move`到外面去, 这样减少了加锁的次数, 又直接通过移动避免了数据的复制, 提高了性能.
   1. 在Stop函数中将`notify_all`放到`lock_guard`保护范围之外, 因为`notify_one`或`notify_all`会唤醒一个在等待的线程, 线程被唤醒后, 会先获取`mutex`再检查条件是否满足, 如果这时被`lock_guard`保护,被唤醒的线程则需要`lock_guard`析构释放`mutex`才能获取. 如果在`lock_guard`之外`notify_one`或`notify_all`, 被唤醒的线程获取锁的时候不需要等待`lock_guard`释放锁, 性能会好一点, 所以在执行`notify_one`或`notify_all`时不需要加锁保护.



# <a name="11">2. 语法基础相关</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

## <a name="12">2.1 智能指针</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

* 智能指针有三种
  1. `unique_ptr`实现**独占式拥有**或**严格拥有**概念, 采用了**所有权**模式, 保证时间智能有**一个**智能指针可以指向该对象
  2. `shared_ptr`(共享型,强引用)实现**共享式拥有**概念,**多个**智能指针可以指向相同对象,该对象和其相关资源会在"最后一个引用被销毁"时释放,使用**计数机制**来表明资源被几个指针共享
  3. `weak_ptr`(弱引用)是一种**不控制对象生命周期**的智能指针, 它指向一个`shared_ptr`管理的对象. 进行该对象的内存管理的是那个强引用的`shared_ptr`; `weak_ptr`只是提供了对管理对象的一个访问手段, `weak_ptr`设计的目的是为了配合`shared_ptr`而引入的一种智能指针用来协助`shared_ptr`工作, 它只可以从一个`shared_ptr`或另一个`weak_ptr`对象构造, 它的构造和析构不会引起引用计数的增加或减少.
  4. `weak_ptr`是用来解决`shared_ptr`相互引用的死锁问题, 如果说两个`shared_ptr`相互引用, 那么这两个指针的引用计数永远不可能下降为0, 也就是资源永远都不会释放. 它是**对对象的一种弱引用, 不会增加对对象的引用计数**, 和`shared_ptr`之间可以相互转换, `shared_ptr`可以直接复制给它, 它可以通过调用`lock`函数来获得`shared_ptr`
  5. 当两个智能指针都是`shared_ptr`类型的时候, 析构时两个资源引用计数会减一, 但是两者引用计数还是为1, 导致跳出函数时, 资源没有被释放(析构函数没有被调用), 解决办法: 把其中一个改为`weak_ptr`就可以

## <a name="13">2.2 C++中的内存分配情况</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

* 栈: 由编译器管理分配和回收, 存放局部变量和函数参数
* 堆: 由程序员管理, 需要手动new malloc delete free 进行分配和回收, 空间较大, 但可能会出现内存泄漏和空闲碎片的情况.
* 全局/静态存储区: 分为初始化和未初始化两个相邻区域, 存储初始值和未初始化的全局变量和静态变量.
* 常量存储区: 存储常量, 一般不允许修改
* 代码区: 存放程序的二进制代码



## <a name="14">2.3 C++中的指针参数传递和引用参数传递</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

* **指针参数传递本质上是值传递,** 它所传递的是一个地址值. 
* **值传递的特点**是, 被调用函数对形式参数的任何操作都是作为局部变量进行的, **不会影响**主调函数的的**实参变量**的值. (形参指针变了, 实参指针不会变)
* 引用参数传递过程中, 被调函数的形式参数也作为局部变量在栈中开辟了内存空间, 但是这是存放的是由主调函数放进来的**实参变量**的地址.
* **引用传递和指针传递是不同的**,他们虽然都是在被调函数栈空间上的一个局部变量, 但是**任何对于引用参数的处理**都会通过一个间接寻址的方式**操作到主调函数的相关变量**. 而**对于指针传递的参数**, 如果改变**被调函数中的指针地址**, 它将会**应用不到**主调函数的相关变量. 如果想通过指针参数传递来改变主调函数中的相关变量(地址), 那就得使用**指向指针的指针**或者**指针引用**



## <a name="15">2.4 C++中的const和static关键字</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

`static`作用: 控制变量的存储方式和可见性

1. 修饰局部变量: 一般, 局部变量在程序中是存放在栈区的, 并且局部的生命周期在包含语句块执行结束时,便结束了.如果使用`static`,变量便会存放在静态数据区,生命周期会一直延续到整个程序结束.(注意:其生命周期发生变化,但是其作用域没有改变)
2. 修饰全局变量:  用`static`对全局变量进行修饰改变了其作用域范围, 由原来的整个工程可见,**变成了本文件可见.**
3. 修饰函数: 也是改变了函数的作用域,和修饰全局变量类似
4. 修饰类: 
   1.  对类的某个函数修饰,则表示该函数属于一个类,而不是属于此类的任何特定对象; 
   2. 对类的某个变量修饰, 表示该变量以及所有的对象所有, 存储空间只存在一个副本, 可以通过类和对象去调用

`const`作用: 

1. 修饰基本数据类型: 表示常量的值不能更改.
2. 修饰指针变量和引用变量:
   1. `const`位于星号左边, 表示`const`用来修饰指针指向的变量不能更改
   2. `const`位于星号右边, 表示`const`用来修饰指针本身,指向的对象不能更改.
3. 应用到函数中: 
   1. `const`作为参数,保护原对象的属性(参数`const`通常用于参数为指针或引用的情况)
   2. `const`作为返回值的修饰符:   也是起保护作用
4. 在类中的用法:
   1. `const`成员变量只在某个对象生命周期内是常量, 而对于整个类而言是可以改变的
   2. `const`成员函数: 防止成员函数修饰对象的内容.
5. 修饰类对象,定义常量对象: **常量对象**只能调用常量函数, 别的成员函数都不能调用.(`const`成员函数中如果实在想修改某个变量,可以使用`mutable`修饰)



## <a name="16">2.5 C和C++的区别</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

语法上没有过大的区别

1. C++有新增的语法和关键字	

   1. 语法的区别有头文件的不同和命名空间的不同,C++允许我们自定自己的空间
   2. 动态内存管理的方式不同,C++中在`malloc`和`free`基础上增加了`new`和`delete`,在指针的基础上增加了引用的概念

2. 函数方面C++有重载和虚函数的概念; 虚函数可以实现多态

3. C的`struct`与C++的类不同: `C++`中的`struct`不仅可以有成员变量还可以有成员函数,而且对`struct`增加了权限访问的概念(默认都是public),C++中还有`class`表示类,但是`class`的默认成员访问权限和默认继承权限都是`private`

4. C++增加了模板还重用代码, 提供了更加强大的STL标准库

   

## <a name="17">2.6 C++与Java的区别</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

1. **指针**: Java语言让程序员没法找到指针来访问内存, 没有指针的概念, 并有内存的自动管理功能,但是Java虚拟机内部还是用了指针
2. **多重继承**: C++支持多重继承但是Java不支持,但是支持一个类几个多个接口, 实现了C++中多重几继承的功能, 又避免了C++的多重几个带来的不便
3. **数据类型和类**: Java是完全面向对象的语言, 所有函数和变量必须是类的一部分. 除了基本数据类型之外, 其余的都作为类对象, 对象将数据和方法结合起来, 把它们封装在类中, 这样每个对象都可以实现自己的特点和行为.
4. **自动内存管理**: Java程序中所有对象都是用`new`操作符建立在内存堆栈上, Java自动进行无用内存回收操作, 不需要程序员手动删除; 而C++中必须由程序员释放内存资源, 增加了程序设计者的负担.C++主要采用RAII技术(资源获得即初始化)和智能指针来完成对资源的控制.
5. Java不支持操作符重载. 操作符重载被认为是C++的突出特征
6. Java不支持预处理功能. C++在编译过程中都有一个预编译阶段, Java没有预编译器.
7. **类型转换**: C++中含有数据类型隐含转换的机制, Java中需要限时强制类型转换
8. Java的异常机制用于捕获例外时间, 增强系统容错能力



## <a name="18">2.7 C++里是怎么定义常量的? 常量放在内存的哪个位置?</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

* 对于**局部常量**, 存放在**栈**区
* 对于**全局常量**, 编译期一般不分配内存, 放在**符号表**中以提高访问效率.
* **字面值常量**, 比如**字符串**, 放在**常量区**.

## <a name="19">2.7 C++中重载和重写, 重定义的区别</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

**重载**

翻译自`overload`是指统一可访问去内被声明的几个具有不同参数列表的同名函数, 依赖于C++函数名字的修饰会将参数加在后面, 可以是参数类型,个数,顺序的不同.(重载不关心函数的返回值)

**重写**

翻译自`override`,派生类中重新定义父类除了函数体之外的所有虚函数, 被重写的函数不能是`static`的, 一定要是虚函数, 且其他一定要完全相同. 重写函数的访问修饰符可以不同, 尽管`virtual`中是`private`的, 派生类中重写可以改为`public`

**重定义**

派生类重新定义父类中相同名字的非`virtual`函数, 参数列表和返回类型都可以不同,即父类中除了定义成`virtual`且完全相同的同名函数才不会被派生类中的同名函数所隐藏(重定义)



## <a name="20">2.9 介绍C++所有的构造函数</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

类的对象被创建时, 编译系统为对象分配内存, 并自动调用构造函数, 由构造函数完成成员的初始化工作. 即构造函数的作用: 初始化对象的数据成员.

1. **无参数构造函数**: 即默认构造函数, 如果没有明确写出无参数的构造函数, 编译器会自动生成默认的无参数构造函数, 函数为空, 什么也不做, 如果不想自动生成, 必须自己显示写出一个无参数构造函数.
2. **一般构造函数**: 也成为重载构造函数, 一般构造函数可以有各种参数类型, 一个类可以有多个一般构造函数函数, 前提是参数的个数或者类型不同, 创建对象时根据传入参数不同调用不同的构造函数.
3. **拷贝构造函数**: 拷贝构造函数的函数参数为对象本身的引用, 用于根据一个已存在的对象复制出一个新的该类的对象, 一般函数中会将已存在的对象的数据成员的值一一复制到新创建的对象中. 如果没有显示的写拷贝构造函数, 则系统会默认创建一个拷贝构造函数, 但当类中有指针成员时, 最好不要使用编译器提供的默认的拷贝构造函数, 最好自己定义并且在函数中执行深拷贝.
4. **类型转换构造函数**: 根据一个指定类型的对象创建一个本类的对象, 也可以算是一般构造函数的一种, 这里提出来, 是想说有的时候不允许默认类型转换的话, 要记得将其声明为`explict`的, 来阻止一些隐式转换的发生.
5. **赋值运算符的重载**: 类似拷构造函数, 将 = 右边的本类对象的值复制给 = 左边的对象,它不属于构造函数, = 左右量变的对象必须是已经被创建., 如果没有显示写赋值运算符的重载, 系统也会生成默认的赋值运算符.

## <a name="21">2.10 C++的四种强制类型转换</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

包括: `static_cast`,`dynamic_cast`,`const_cast`, `reinterpret_cast`

* `static_cast`: 明确指出类型转换, 一般建议将隐式类型转换都替换成显示转换, 因为**没有动态类型检查**, **上行**转换(派生类->基类)是**安全**, **下行**转换(基类->派生类)**不安全**,所以主要执行非多态转换操作.
* `dynamic_cast`: 专门用于派生类之间的转换,对于下行转换是安全的, 当类型不一致时, 转换过来的是空指针, 而`static_cast`, 当类型不一致时, 转换过来的事错误意义的指针, 可能造成非法访存等问题.
* `const_cast`: 专门由于`const`属性的转换, 去除`const`性质, 或增加`const`性质, 是四个转换符中唯一一个可以操作常量的转换符. 
* `reinterpret_cat`: 高危操作转换符, 从底层对数据进行重新解释, 依赖具体的平台, 可移植差; 可以将整形转换为指针, 也可以把指针转换为数组,;可以在指针和引用之间肆无忌惮的转换.

## <a name="22">2.11 指针与引用的区别</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

指针和引用都是一种内存地址的概念,在程序编译的时候都会添加到符号表中, 区别: 指针是一个实体, 引用是一个别名

* 指针**指向一块内存,** 指向的内容是内存的地址,内容可以改变, 允许赋值和拷贝, 有`const`和非`const`区别,可以为空,`sizeof`指针得到的是指针类型的大小.
* 对于引用, 是一块内存的别名, 引用必须而且只能定义时被绑定到一块内存上, 后续不能更改, 也不能为空, 也没有`const`与非`const`的区别
* 在参数传递中, 指针需要被解引用才可以对对象进行操作, 而直接对引用进行的修改会直接作用到引用对象上
* `sizeof`引用得到代表对象的大小, 而`sizeof`指针得到的是指针本身的大小
* 作为参数时也不同, 传指针的实质是传值, 传递的是指针的地址; 传引用的实质是传地址, 传递的是变量的地址

## <a name="23"> 2.12 野指针(wild)与悬空(dangling)指针有什么区别? 如何避免?</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

野指针: 没有初始化过的指针, 可以用智能指针避免

悬空指针: 是指针最初指向的内存已经被释放了的一种指针.

两种都是指向无效内存区域,不安全不可控

## <a name="24">2.13 函数指针和指针函数</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

* 函数指针: 指向函数的指针,本身是一个指针变量, 指向一个具体的函数, 用途是调用函数和做函数的参数,比如回调函数

* 指针函数: 带指针的函数,本质是一个函数, 函数返回类型是某一类的指针.

  

## <a name="25">2.14 堆与栈的区别</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

* 栈由编译器进行管理, 在需要时由编译器自动分配空间, 在不需要时,自动回收空间, 一般保存的是局部变量和函数参数等.高地址向低地址扩展,栈低高地址, 空间较小
* 堆由程序员管理,需要手动`new malloc delete free`进行分配和回收, 否则内存泄漏,低地址向高地址扩展,较为灵活

## <a name="26">2.15  new/delete malloc/free的区别</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

都可以用来在堆上分配空间. `new/delete`是操作符, `malloc/free`是库函数

* 执行`new`实际上执行两个过程: 1.分配未初始化的内存空间(`malloc`) , 2.使用对象的构造函数对空间进行初始化; 返回空间的首地址.
* 执行`delete`也有两个过程: 1.使用析构函数对对象进行析构; 2. 回收内存空间

为什么有了 `malloc/free`还需要`new/delete`?

* 因为对于非内部数据而言, 光用`malloc/free`无法满足动态对象的需要. 对象在创建的同时需要自动执行构造函数, 对象在消亡以前要自动执行析构函数. 由于`malloc/free`是库函数而不是运算符,不在编译器控制权限之内,不能把执行的构造函数和析构函数的任务强加于`malloc/free`,所有有了`new/delete`操作符

## <a name="27">2.16 volatile和extern关键字</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

`volatile`: 让编译器放弃对修饰变量的优化, 三个特征: **易变性**, **不可优化性**,**顺序性**

在C语言中,`extern`用在变量前或者声明的函数前, 用来说明 "此变量/函数是在别处定义的,要在此处引用", 用`extern" 会加速程序的编译过程, 能节省时间

## <a name="28">2.17 define和const的区别(编译阶段,安全性,内存占用等)</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

对于`define`来说,宏定义实际上在预编译阶段进行处理, 没有类型,也没有类型检查,遇到宏定义就展开,容易出现边界效应

对于`const`来说,是在编译期间处理, const有类型, 也有类型检查, 程序运行时系统会为const常量分配内存,只保留一份数据的拷贝,省去了不必要的内存空间, 有时不会为普通的const常量分配内存, 而是直接将`const`常量添加到符号表.



## <a name="29">2.18 面向对象的三大特征</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

封装,继承,多态

* **封装**就是把客观事物封装成抽象的类, 同时类可以把自己的数据和方法只让信任的类或者对象操作, 对于不可信的进行信息隐藏.public, protected
* **继承**可以让某个类型的对象获取另一个类型的对象的属性的方法. 要实现继承,可以通过"继承"和"组合"来实现
  * 继承概念的实现方法有两种:
    * 实现继承: 实现继承是直接使用基类的属性和方法而无需额外编码的能力.
    * 接口继承: 接口继承是指仅使用属性和方法的名称, 但是子类必须提供实现的能力.
* **多态**:就是向不同的对象发送同一个消息,不同对象在接收时会产生不同的行为(即方法), 即一个接口, 可以实现多种方法.
  * 多态与非多态的实质区别就是函数地址是早绑定还是晚绑定的. 如果函数的调用, 在编译器编译期间就可以确定函数的调用地址, 并产生代码,则是静态的, 即地址早绑定. 而如果函数调用的地址**不能在编译器期间确定, 需要在运行时才确定, 这就属于晚绑定**

## <a name="30">2.19 多态的实现</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

多态其实一般就是**指继承加虚函数实现的多态.**

多态分为**静态多态**和**动态多态**

* 静态多态其实就是重载, 因为静态多态是指编译期间就决定了调用哪个函数, 根据参数列表来决定
* 动态多态是指通过子类重写父类的虚函数来实现的, 因为是**在运行期间决定调用的函数**, 所有成为动态多态. 动态多态的实现与虚函数表, 虚函数指针相关

## <a name="31">2.20 析构函数一般写成虚函数的原因</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

为了降低内存泄漏的可能性.

如果基类的析构函数定义成虚函数, 那么编译器就可以根据实际对象, 执行派生类的析构函数, 再执行基类的析构函数,成功释放内存.



## <a name="32">2.21 构造函数的执行顺序? 析构函数的执行顺序?</a><a style="float:right;text-decoration:none;" href="#index">[Top]</a>

**构造函数**顺序

*  基类构造函数
* 成员类对象构造函数
* 派生类构造函数

**析构函数**顺序

* 调用派生类的析构函数
* 调用成员类对象的析构函数
* 调用基类的构造函数
