# 飞利浦面试题

## 1. C++11里面用过哪些特征？

- 自动类型推导（auto）：允许编译器根据初始化表达式的类型推断变量的类型。
- 智能指针（std::shared_ptr, std::unique_ptr）：提供了更安全、更易于管理的内存管理机制，避免了显式使用 new 和 delete。
- Lambda表达式：允许在代码中定义匿名函数，便于在函数内部定义和使用简单的功能代码块。
- 右值引用与移动语义：通过 && 实现右值引用，引入移动构造函数和移动赋值运算符，提高了对象在内存中的处理效率。
- 初始化列表：允许使用统一的语法来初始化各种类型的对象，包括数组、结构体和类对象。
- foreach循环（range-based for loop）：简化了对容器和数组的遍历操作，使代码更加简洁和易读。

## 2.智能指针一定能避免内存泄露吗？

两个对象相互持有 shared_ptr 指向对方，解决：使用weak_ptr 
不会自动管理通过其他手段分配的资源
与裸指针混用导致提前释放或悬挂指针

## 3.C++哪些特征你推荐使用？哪些不推荐?

推荐： Nullptr空指针，	unique_ptr智能指针，围for循环，constexpr(埃克斯拜耳)编译期求值， default/delete, override/final
不推荐：  shared_ptr滥用，new来创建指针，bind(使用lambda代替—),  decltype类型推导除非模板

## 4.UML图：

 活动图，时序图，数据流图，类图，包图，组件图，用例图，使用visio(威醒)

## 5. SVN 采用线性版本历史,而git使用分布式，每个人提交的历史不一样

SVN 天然支持大文件、二进制文件版本管理，而git不支持
文档审查，SVN更可靠

## 6.什么是虚函数？

虚函数（virtual function）是C++中实现运行时多态（Runtime Polymorphism）的关键机制，它允许基类指针或引用调用派生类中覆盖的函数，
使得程序在运行时根据对象的真实类型选择合适的函数。
C++ 使用 虚函数表（vtable）+ 虚指针（vptr） 机制实现运行时多态

## 7.多态如何理解？

多态（Polymorphism）是面向对象程序设计（OOP）的核心特性之一，表示同一个接口或函数调用，在不同对象上表现出不同的行为。

## 8.如何理解纯虚函数？

在基类中定义抽象接口，在派生类中实现重写的函数，为多态行为提供统一接口。

## 9.编译时多态和运行时多态

编译时多态 指的是函数重载和模板

运行时多态指的是函数重写

## 10.纯虚函数的类能创建一个对象吗？

不能，C++语法之一，纯虚函数类只提供接口和行为约束。

## 11. 什么是函数的重载?

 函数的重载（Function Overloading）是 C++ 中的一种编译时多态机制，指在同一个作用域内，
 定义多个函数名相同但参数不同的函数，由编译器根据参数来选择调用哪个版本。
 返回值不同也不构成重载。

## 12. 拷贝构造函数？

用于创建一个类对象的副本，会在
使用一个已有对象来初始化一个新对象时被调用
将一个对象传递给函数时
将一个对象从函数返回时
调用
额外的： 拷贝赋值和拷贝构造都必须是深拷贝



## 13.什么是右值和右值引用？

主要用于优化资源管理、避免不必要的对象拷贝，提高性能。
右值是一个临时对象，它通常表示不可修改的值，或者说它是一个将要被销毁的对象。
字面量：如 42、3.14、'a'、"hello" 等。
右值引用允许我们对临时对象的资源进行转移，而不是复制，从而避免不必要的内存分配和拷贝操作。
就是把原来资源的内存和数值交给新的对象，原来的对象就不再使用了。

## 14.什么叫移动构造函数？

它通过转移资源来避免不必要的拷贝，提高程序的性能。
移动构造函数允许将临时对象的资源（如动态内存）从一个对象“转移”到另一个对象，而不是复制它们。
避免对资源的深拷贝，从而提高性能。
从一个即将销毁的临时对象（右值）中“窃取”资源，并将这些资源赋值给新对象。

## 15. git常用命令

git reset file 从暂存区撤销文件，保留工作区内容。
git status: 查看当前仓库状态
git merge : 合并指定分支
git branch: 列出分支

## 15. Git里面的默认的缺省分支叫什么名字？主线分支？

main, 原来叫master

## 16. 线程同步有没有用过？怎么做？ 除了加锁之外还有哪些？
std::lock_guard（尬德)RAII 风格自动加锁解锁
std::atomic （额淘米可)  原子变量计数
条件变量： 用于线程间的等待/通知机制
C++20引入了信号量



## 17.Qt信号槽机制

在 Qt 中，信号与槽机制（Signal and Slot）是核心特性之一，用于对象间通信。

通过 `QObject::connect()` 第五个参数指定，决定信号和槽是同步还是异步调用：

| 连接方式                     | 枚举值                         | 特点说明                                                 |
| ---------------------------- | ------------------------------ | -------------------------------------------------------- |
| **自动连接**                 | `Qt::AutoConnection`           | 默认，跨线程时是队列连接；同线程是直接连接               |
| **直接连接**                 | `Qt::DirectConnection`         | 同步调用，信号发出立即执行槽函数                         |
| **队列连接**                 | `Qt::QueuedConnection`         | 异步调用，信号发出后槽函数排入事件队列，适用于线程间通信 |
| **强制异步连接（Blocking）** | `Qt::BlockingQueuedConnection` | 跨线程使用，阻塞发送线程直到槽函数执行完（⚠ 可能死锁）   |
| **唯一连接（避免重复连接）** | `Qt::UniqueConnection`         | 与其他类型组合使用，防止重复连接同一信号槽对             |



## 18.软件设计模型

**中介者模式 (Mediator Pattern):**

- **用途:** 医疗仪器中的设置模块经常需要协调多个其他模块的行为（例如，改变一个设置可能需要通知诊断模块重新计算参数，通知硬件抽象层更改寄存器，通知数据记录模块记录设置变更等）。如果设置模块直接与所有这些模块通信，耦合会非常高。
- **如何应用:** 可以引入一个“设置管理器”或“系统协调器”作为中介者。所有需要与其他模块交互的请求（例如“应用设置 X”）都通过这个中介者转发。中介者知道哪些模块对这个设置变更感兴趣，以及调用它们的顺序和方式。这减少了设置模块与其他模块之间的直接依赖。
- **优点:** 降低了模块间的耦合度，集中了交互逻辑，使得单个模块更容易理解和维护。



**观察者模式 (Observer Pattern) / 发布-订阅模式 (Publish-Subscribe Pattern):**

- **用途:** 当设置模块的某个设置发生变化时，许多其他模块可能需要得到通知并做出反应（例如，更改了通信端口设置后，通信模块需要重新初始化；更改了治疗参数后，治疗模块需要更新其算法）。这些对变更感兴趣的模块不应该直接依赖于设置模块。

- **如何应用:** 设置模块可以成为一个“被观察者”，或者系统可以有一个消息总线/事件中心。当一个设置变更发生时，设置模块（或通过中介者）发布一个事件（如 "SettingChangedEvent"），其他对这个事件感兴趣的模块可以注册为“观察者”或“订阅者”，从而接收通知并执行相应的更新逻辑。

- **优点:** 实现了模块间的松耦合，模块只需要关心它感兴趣的事件，而不需要知道谁触发了事件。提高了系统的灵活性和可扩展性。

  

**命令模式 (Command Pattern):**

- **用途:** 设置模块通常会处理一系列的配置动作。这些动作（如“设置增益”、“设置阈值”）可以被封装成独立的命令对象。这在需要支持设置的排队、日志记录、撤销/重做或参数化操作时非常有用。
- **如何应用:** 定义一个 `Command` 接口，为每种设置操作创建一个具体的命令类（如 `SetGainCommand`, `SetThresholdCommand`）。设置模块（或其 ViewModel/Presenter）接收到用户请求后，创建一个相应的命令对象，并将其发送给一个命令处理器或队列。
- **优点:** 将请求的发送者与接收者解耦，支持命令的排队、记录、撤销等功能，方便扩展新的命令。



**状态模式 (State Pattern):**

- **用途:** 医疗仪器的设置或硬件配置过程可能涉及复杂的、依赖于当前状态的流程（例如，只有在设备处于“待机”状态时才能修改某些设置；修改设置的流程可能包含“验证参数”、“发送到硬件”、“等待确认”、“应用成功/失败”等多个阶段）。
- **如何应用:** 将设置或配置流程的不同阶段表示为不同的状态对象。设置模块的内部逻辑或硬件交互部分可以委托给当前状态对象来处理请求，从而根据当前状态执行不同的行为。
- **优点:** 将与状态相关的行为封装到独立的状态类中，避免了大量的条件判断 (`if/else if`)，使得状态转换逻辑更清晰、易于维护和扩展。



**依赖注入 (Dependency Injection - DI) / 服务定位器 (Service Locator):**

- **用途:** 设置模块需要依赖于硬件抽象层、数据存储服务、其他业务模块的服务等。直接在模块内部创建或查找这些依赖会导致紧耦合，不利于测试和替换。

- **如何应用:** 使用 DI 框架或手动方式，在创建设置模块时将它所依赖的其他模块或服务作为参数传递给它。或者使用服务定位器模式，让模块通过一个注册中心获取它所需的服务实例。

- **优点:** 降低了模块间的耦合度，提高了代码的可测试性（可以轻松地注入 Mock 或 Stub 对象进行单元测试）和可维护性，方便替换依赖实现。

  

**硬件抽象层 (Hardware Abstraction Layer - HAL):**

- **用途:** 虽然这不是一个设计模式，但对于与硬件交互的组件（如设置模块需要配置硬件参数）至关重要。它将上层软件逻辑与底层硬件细节隔离开。
- **如何应用:** 定义一组标准的接口，用于访问和控制硬件。设置模块只通过这些接口与 HAL 交互，而不知道具体的硬件实现细节（如寄存器地址、通信协议等）。不同的硬件平台可以提供不同的 HAL 实现。
- **优点:** 提高了软件的可移植性（更换硬件平台时只需更换 HAL 实现），降低了软件与硬件的耦合度，使得上层逻辑更清晰。



**结合使用:**

在医疗仪器组件中，通常会结合使用多种模式。例如：

- UI 部分使用 **MVVM** 来分离视图和视图模型。
- ViewModel 处理用户的 UI 交互，并通过 **命令模式** 将设置请求封装起来。
- ViewModel 或一个专门的“设置服务”与 **中介者** 交互。
- 中介者协调 **硬件抽象层**、数据存储模块、其他业务模块来完成设置的实际应用。
- 设置的应用过程可能由 **状态模式** 管理。
- 其他模块通过 **观察者模式** 订阅设置变更通知。
- 整个系统的依赖通过 **依赖注入** 管理。



## 19.项目消息总线相关

解决接口依赖的强耦合关系。对象之间的关系一般有： 依赖，关联，聚合，组合和继承。在大型项目中关联关系非常复杂。

消息的注册是为了告诉总线该对象对某种消息感兴趣，希望收到某种主题和类型的消息。总线内部维护了一个消息队列，当需要发送消息时，遍历消息队列，从中查找是否有合适的消息和消息接受者，找到合适的接收者之后再进行广播消息。注册的泛型函数要是所有可能调用对象，包括普通函数，成员函数，函数对象，function和lambda表达式



关键技术： 

（1） 通用的消息定义

​	消息总线技术的本质是让所有的对象都通过消息来联系

（2)消息的注册

让所有的消息都可以注册感兴趣的消息

（3）消息的分发

通过消息总线分发消息，让所有的接收者都能收到并处理消息。



使用，car和bus注册了主题，消息类型为void(int) 的消息，当subject发送Drive的主题时，只有注册了该主题的对象才会收到详细。另外还有移除主题的功能。





## 20.线程间通信(5种)

1. 共享内存配合同步机制
2. 消息传递，消息队列
3. 互斥锁和条件变量
4. 原子操作（原子计数器）

## 21.进程间通信方式（8种）

1. 管道
2. 命名管道
3. 信号
4. 信号量
5. 内存映射
6. 共享内存
7. Socket
8. 消息队列

## 22.数据库大量日志处理

在处理大量数据时，游标可以避免一次性将所有数据加载到内存中，从而减少内存消耗。 
索引是用于加速数据查找的结构。 它们帮助数据库快速定位满足查询条件的数据行，而无需扫描整个表。
游标是在查询执行后，对返回的结果集进行遍历的机制。
分区缩小了查询范围
游标降低了内存消耗:
将日志按照日期分区
一个大型的日志表可能首先按日期进行分区以提高查询性能和管理效率，然后在用户界面上显示查询结果时，再使用分页来控制每次显示的数据量。